---
bibliography: citations/referenceliste.bib
csl: citations/university-college-lillebaelt-harvard.csl
output: 
  pdf_document:
    includes:
      in_header: import.sty
      before_body: title.sty
toc-title: IndholdsfortegnelseK
---

```{r echo=FALSE}
#install.packages("kableExtra")
#install.packages("WDI")
#install.packages("cowplot")
#install.packages("magick")
#install.packages("png")
```


# Problemformulering


# Indledning

Med denne hovedopgave vil jeg præsentere et bredt overblik over fundementale webteknologier, i form af programmeringssprog, værktøjer og biblioteker, som knytter sig til moderne webudvikling, specielt med hensyn til HTML, CSS og JavaScript. I forhold til spørgsmålet om, hvad der udgør moderne webudvikling, er der delte meninger. Jeg har derfor udvalgt enkelte teknologier at beskrive med begrundelse i offentliggjorte udviklerundersøgelser og efter min personlige præferencer. Tempoet hvormed nye webteknologier introduceres og tages i brug er hastigt stigende. Jeg vil derfor med hovedopgaven også undersøge muligheden for at bygge en microfrontend arkitektur, som kan omkranse adskillelige frameworks og teknologier og dermed tillade brug af den mest passende teknologi til slutbrugeren og udviklerens behov.

\newpage

# Basale webteknologier

## Internettet og World Wide Web
Internettet er et computernetværk bestående af computernetværk som er forbundet gennem *routere*. En computerenhed, der er forbundet til internettet, kaldes en *host*. For at hosts og routere kan kommunikere, bruger de *TCP/IP protokolstakken*. Det er en gruppe af standarder og software, som tillader enhederne at forstå hinanden efter et fastlagt format. Protokolstakken kan inddeles i lag for protokollernes forskellige ansvarsområder.



```{r echo = FALSE}
library("knitr")
tableData <- c("Applikationslag","HTTP, SMTP, DNS","Netværkslag", "Test");
protocols_by_layer <- matrix(tableData,ncol=2,byrow=TRUE)
colnames(protocols_by_layer) <- c("Lag", "Protokol")
kable(protocols_by_layer, caption = "TCP/IP protokolstakken")
```

De beskeder, som enheder sender over internettet, bliver opdelt i mange *packets*, som hver især finder vej fra beskedens oprindelse til dens destination. Routerens bestemmer vejen gennem internettet for de mange packets fra oprindelse til destination i en proces der hedder *routing*. Routeren håndterer også *packet switching* ved at betragte hver enkelt packet, som indeholder information om sin egen destination. Routeren slår destinationsadressen op i sin *configuration tabel* for at sende den konkrete packet til den korrekte destination med hensyn til at vælge en ikke overbelastet route. Packet switching er meget effektivt ift. f.eks. *circuit switching*, som holder en kommunikationslinje åben hele tiden, f.eks. traditionel fastnet telefoni. På grund af denne effektivitet steg udbredelsen af internettet eksplosivt i perioden fra 1995-2005[^wdi]:

```{r echo = FALSE, fig.cap = "Brugere af internettet i Danmark", fig.width=4, fig.height=4}
library('WDI')
raw <- WDIsearch("individuals using the internet")
individuals_using_internet <- as.data.frame(raw)
indicator <- toString(individuals_using_internet["indicator", 1])
individuals_using_internet_denmark <- WDI(country = "DK", indicator = indicator, start = 1995, end = 2020)
to_plot <- individuals_using_internet_denmark[c("year", indicator)]
plot(to_plot, type="l", main="", xlab = "Årstal", ylab="% af population")
```

World Wide Web (WWW) opfundet i 1989 for at forskere kunne *hyperlinke* bl.a. deres forskningsartikler. WWW bruger Hypertext Transfer Protocol (HTTP) for at kommunikere mellem *klienter* og *servere*. 


Internettet er 

[^wdi]: @WB, IT.NET.USER.ZS, DK

## HTTP
HTTP/1.1
HTTP/2
https://stackoverflow.com/questions/37556283/what-is-the-value-of-using-webpack-with-http-2

## W3C
“World Wide Web Consortium”

## Heap/Stack (browser?) (flyt?)

## HTML

HTML tags kan have attributter.

## CSS
CSS (Cascading Style Sheets) deklarerer regler som udgør *stylingen* af HTML dokumentet. Reglerne kan ramme en eller flere HTML elementer afhængigt af den valgte *selector*. Der er selectorer for HTML element typer, HTML element ID og HTMl element klasser. 

Ordet *cascade* i CSS peger på den måde CSS regel konflikter håndteres på en forudsigelig måde.
For det første ser browseren på *stylesheet origin*. Den lavest prioriterede stylesheet origin er *user agent styles*, som er det stylesheet, browseren som standard applikerer. Det er standard styling som farve til hyperlinks og skriftstørrelse. User agent styles kan variere fra fra browser til browser. For at sikre en ens brugeroplevelse på tværs af user agent/browser, kan man bruge et *CSS Reset* stylesheet som **normalize.css* [^normalize].
Stylesheets skrevet af udvikleren, eller som er linket til i HTML dokumentet, kaldes *author styles*, og de overskriver user agent styles.
Det næste browseren vurderer er *specificity*. Reglen med den højeste specificity overskriver andre modstridende regler (med undtagelse af regler deklareret med `!important` annotationen). Den højeste specificity opnås hvis stylingen er deklareret *inline* i HTML elementets `style` attribut. Derefter vurderes specificity fra reglens selector. Hvis selectoren består af HTMl element ID, giver det højere specificity, end hvis den består af HTML element klasser, som igen giver højere specificity, end hvis den består af HTML element typer. En selector med flere ID har højere specificity end én med færre[^cascade].
Endelig vurderer browseren *source order*. Hvis specificity for modstridende regler er den samme, vil den sidste regel overskrive den første.

Udover user agent styles og author styles, kan HTML elementer også nedarve styling ved *inheritance*, hvis den ikke har en værdi fra cascaden beskrevet overfor. Det tillader f.eks. at deklarere en skrifttype for rodelementet, som alle lavere HTML elementer vil arve. Kun nogle properties understøtter inheritance, f.eks. de for text, lister og tabeller.

### Style creep

### Flexbox

### CSS Grid

[^normalize]: https://github.com/necolas/normalize.css
[^cascade]: @farrel

## Browser support (flyt?)

https://whatwg.org/faq

https://whatwg.org/faq#living-standard

## JavaScript
JavaScript blev skabt i 1995. JavaScript er i dag så allestedsnærværende på internettet, at mange websider ikke engang virker uden JavaScript. JavaScript er det mest populære programmeringssprog, og har været det siden 2013[^so].


```{R echo = FALSE, fig.cap = "Popularitet af programmeringssprog", fig.width=4, fig.height=4}
language_by_popularity <- data <- data.frame(
  name=c("JavaScript","SQL","Java","C#"),  
  value=c(67.8,54.4,41.1,31)
)

library(ggplot2)
# Basic barplot
# reorder https://stackoverflow.com/a/16968999
p<-ggplot(data=language_by_popularity, aes(x=reorder(name, -value), y=value)) +
  geom_bar(stat="identity")
p + xlab("") + ylab("% af adspurgte udviklere, som bruger sproget")
```

### Standardisering
I 1996 blev JavaScript indsendt til ECMA International som håndterer webstandarder. Dermed kunne konkurrende JavaScript engines kunne en fælles standard, så alle JavaScript *hosting environments* som fx en *browser* kunne afvikle og præsentere JavaScript uden at afvige fra hinanden. Der findes flere forskellige JavaScript *engines*, som alle kører JavaScript kode efter samme standard. Standarden hedder ECMA-262, men kaldes ECMAScript og forkortes ofte *ES*. ES3 udkom i 1999, men der blev ikke udgivet en ny version før 2009, hvor ES5 udkom. Microsoft havde en implementation af standarden, som de kaldte JScript. JScript og JavaScript havde i begyndelsen alligevel væsentlige forskelle. Forskellene blev med tiden udvandet, og i dag er der mange forskellige JavaScript engines, fx. SpiderMonkey (brugt af Firefox), Chakra (brugt af Edge) og V8 (brugt af Chrome). 


### Scope (block, function, ?)

### Compiler, runtime
https://stackoverflow.com/questions/29027845/what-is-the-difference-between-javascript-engine-and-javascript-runtime-environm
https://medium.com/@andrewrymaruk/v8-a-few-words-about-javascript-engines-882dc2cf6799

### Datatyper

JavaScript har overordnet to forskellige datatyper af værdier, som kan opbevares i variable. Det er *primitiver* (værdityper), som opbevares på stack, og *objekter* (referencetyper), som opbevares på heap.  Primitiver er simple værdier, som JavaScript har syv forskellige typer af: `Number`, `Boolean`, `String`, `Null`, `Undefined`, `Symbol` (introduceret i ES6) og `BigInt` (introduceret i ES7). Objekter består af *properties*, som er navngivne primitiver eller objekter. Properties kan også indeholde *functions*, som i Javascript er specielle objekter af typen `Function`, og *arrays* af primitiver og/eller objekter, som i JavaScript også er specielle objekter, der har typen `Array`. Functions og arrays er altså som næsten alt andet i JavaScript objeker, selvom syntaksen for at bruge disse specielle objekter er lidt anderledes. Man opretter generelt brugerdefinerede objekter ved at bruge *object literal* syntaksen:


```{js}
// objekt
const animal = {
  // properties
  alive: false, // simpel værdi
  position: { // objekt
    x: 0,
    y: 0,
  },
  walk: function (x, y) { // metode
    this.position.x = x;
    this.position.y = y;
  },
};
```

### Browseren
https://javascript.info/browser-environment
JavaScript kører i et *host environment* (hostmiljø) som fx en *browser*. Hostmiljøet er ansvarlig for at gøre specifikke objekter tilgængelige for udvikleren. Alle browsere giver f.eks. adgang til `document` objektet, som kan manipulere det hierarki af *nodes*, som hver især repræsenterer de HTML tags, som udgør det aktuelle HTML dokument.

### DOM

### Nedarvning med prototype pattern
JavaScript er et objektorienteret sprog, men det har (i modsætning til fx. C#) ikke klasser. For at kunne lave objekter af en bestemt type, bruger man en *constructor funktion*, Denne specielle metode navngives konventionelt med stort begyndelsesbogstav. På constructor funktionen er der en property `prototype`, som indeholder et objekt. Ved at sætte properties på prototype objektet, angiver man hvilke felter, som skal være på objekter skabt med constructor funktionen. Når man laver objekter ved at kalde constructor funktionen med nøgleordet `new`, vil man kunne tilgå de properties og metoder, man har angivet i prototypen.

```{js}
// constructor funktion
function Animal() {
}

// prototype pattern
Animal.prototype.alive = false;
Animal.prototype.position = { x: 0, y: 0 };
Animal.prototype.move = function (x, y) {
  this.position.x = x;
  this.position.y = y;
};
```

Når constructor funktionen kaldes med `new`, får Prototype objektet som standard en `constructor` property, som peger tilbage på den constructor funktion, som prototypen tilhører. For eksempel peger `Animal.prototype.constructor` tilbage på `Animal`.  og `__proto__` property, som angiver hhv. typens constructor funktion, og constructor funktionen for den nedarvede type (i sidste ende `Object`).

Hvis man vil specialisere sin constructor function, fx. lave en `Mammal` som specialisering af `Animal`, laver man en ny constructor function, og sætter prototypen til en instans af overtypen.

```{js}
function Mammal(){
}

Mammal.prototype = new Animal();
Mammal.prototype.isPregnant = false;
```

Når man tilgår en property, fx. (???) vil JavaScripts engine søge efter en property med det navn først blandt objektets properties, dernæst i dens prototypes properties, så prototypens __proto__'s properties, osv. indtil roden af nedarvingshiearkiet, som er constructor funktionen `Object`. 

```{r echo=FALSE, fig.cap="Prototypisk nedarvningskæde", fig.height=4, fig.width=4}
library(png)
library(grid)
img <- readPNG("prototypical-inheritance.png")
grid.raster(img)
```

### Nedarvning med klasser
I ES6 blev en ny syntaks indført for at gøre det lettere at arbejde med prototypiske nedarvningskæder. Man kan nu bruge `class` nøgleordet til at definere sine *klasser*. Klasser i JavaScript minder meget om klasser i andre objectorienterede sprog, fx. C#, men de er blot syntaktisk sukker for prototypisk nedarvning. 
https://javascript.info/class
The result of this definition is about the same. So, there are indeed reasons why class can be considered a syntactic sugar to define a constructor together with its prototype methods.

Still, there are important differences.


[^dt]: @projs, Chapter 3, Language Basics
[^so]: @SO, Most Popular Technologies, Programming Scripting and Markup Languages
[^katalog]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference


### static class fields
web components in action appendix

### Moduler
I JavaScript er det muligt at importere *moduler*. Et modul er en kodefil, som kan importeres af andre kodefiler. Moduler tillader at eksportere *named exports*, så man f.eks. kun eksporterer én funktion fra en fil. Der er også mulighed for **default exports*, som kan importeres nemmere, og generelt bruges, hvis moduler har en primær funktionalitet, som skal fremhæves. Default exports behøver ikke navngives, da de navngives ved importeringen. Endelig  Før i tiden var der ingen understøttelse af moduler, så problemet blev løst med kodebiblioteker som CommonJS og RequireJS

# Moderne webudvikling med JavaScript Frameworks

https://frontendmasters.com/books/front-end-handbook/2019/

## Udfordringen ved nye teknologier
https://findresearcher.sdu.dk:8443/ws/portalfiles/portal/157293005/SII2020_Agent_based_Simulation_Design_for_Technology_Adoption_Christensen.pdf

## Sammenligning

Når man dykker ned i de seneste års udvikling indenfor JavaScript frameworks, opstår der et mønster. De tre Javascript frontend frameworks, som flest udviklere har prøvet at bruge er React, Vue og Angular. [billede1]

Det er umuligt at forudse hvilke af disse teknologier der overlever længst, eller 
hvornår de bliver erstattet af noget nyt. Men der tegner sig et billede af, at flere udviklere benytter og udtrykker tilfredshed med Vue og React end Angular. React 
ligger i 2019 placeret #2 på Stack Overflows undersøgelse2 af mest anvendte web 
frameworks (med jQuery fortsat på førstepladsen) og i kategorien ”Most Loved Web 
Frameworks” er React nummer ét med Vue lige i hælene mens Angular halter 
bagefter på en niendeplads. Når man ser på deres indbyrdes popularitet, har Vue 
flest stjerner på dets GitHub repository og er nu det mest populære af de tre: [billede3]

Hvis man måler på hvor meget de respektive web frameworks downloades af udviklere, ligger React i toppen med op imod seks millioner downloads om ugen, sammenlignet med to millioner for Angular og en million for Vue4. Fælles for alle de nævnte web frameworks er, at de er open source. Store virksomheder som Google, Facebook og Microsoft har taget open source forretningsmodellen til sig og er med til puste til ilden af konstant innovation. React er udviklet og drevet af Facebooks senior softwareingeniøre. Google står bag Angular, mens Microsoft står bag dets anvendte open source programmeringssprog TypeScript. Vues styrke ligger bl.a. i, at det ikke har en stor virksomhed i ryggen som driver udviklingen, men er finansieret af crowdfunding og kombinerer det bedste fra Angular og React.

## React
React er et JavaScript kodebibliotek til at bygge brugergrænseflader baseret på komposition af komponenter. Alting i React er en komponent, og selv hele applikationen er en komponent, som er sammensat af de øvrige komponenter. Komponent strukturen gør det muligt at genbruge og indkapsle alt lige fra en simpel checkbox til en hel applikation. Det gør det også nemt at ændre komponenterne og f.eks. tilføje yderligere state, uden at det skaber en dominoeffekt af side effekter i resten af applikationen. Komponent modellen passer ikke så godt med objekt modellen, og principper vi kender som søjler i objekt orienteret programmering, er ikke anvendelige eller har bedre løsninger i React. Facebook promoverer stærkt ”Composition over Inheritance”, og udtaler at de aldrig har brugt nedarvning i deres tusindevis af komponenter. [komponenter-billede]

React koncentrerer sig kun om brugergrænsefladen, og det er både en fordel og en ulempe. Langt de fleste React projekter vil have behov for at hente yderligere tredjeparts pakker ned for at håndtere problemer, som f.eks. Angular har indbyggede løsninger på. React omtales ofte heller ikke som et framework men et kodebibliotek, og man sammenligner det ofte med View-laget i MVC. Det gode ved Reacts minimalistiske tilgang er, at der er stor fleksibilitet i hvordan man løser et givent problem, og der er mange højt specialiserede værktøjer til at håndtere nicher som f.eks. routing eller global state. 

React har hvad man kalder en deklarativ API. I stedet for at beskrive hvert trin og i hvilken rækkefølge, man opdaterer de enkelte elementer på brugergrænsefladen (imperativt), så beskrives hvordan man ønsker (deklarerer), at brugegrænsefladen skal se ud afhængigt af dens tilstand. 

 
### Komponenter og props
En React komponent er ikke andet end en funktion, som returnerer noget, der i bund 
og grund bare er HTML. Strukturen og indholdet kan evt. afhænge af nogle 
funktionsparametre – eller hvad man i React termer ville kalde props. Disse props 
følger et princip om unidirectional data flow, eller en-vejs databinding. Props kan kun 
sendes fra forældre-komponent til barn-komponent.   

Det hænger sammen med en anden egenskab ved props, som er, at de skal være 
immutable. En komponent kan læse sine props, men ikke overskrive dem. Eftersom 
en komponent modtager sine props som input, betyder det at man undgår side 
effekter i sine komponenter. Med andre ord, vil de samme props som input altid 
generere det samme HTML som output. Man siger, at komponenten er en pure 
function med hensyn til sine props. Reacts eneste regel er, at alle komponenter skal 
være pure functions mht. sine props. For at en funktion kan være en pure function, 
må den: a) ikke have sideeffekter b) ikke kalde non-pure functions (som Date.now) og 
c) behandle sine argumenter som immutable (readonly). Der findes JavaScript 
kodebiblioteker som ImmutableJS til at håndhæve dette, eller code linting værktøjer 
som ESLint. 

Props kan indeholde callbacks, så en forældre-komponent kan sende en funktion ned til barn-komponenten, som barn-komponenten kan kalde med en eller flere parametre for at sende data til forældre-komponenten. Det er den eneste umiddelbare måde komponenter kan sende data på, til andre end sine børn. Selvom det er med til at gøre programmet nemt at debugge og forstå, virker det umiddelbart som en begrænsning. For eksempel når når to komponenter A og B langt fra hinanden i træhiearkiet skal bruge data fra hinandens props. Det kræver at en fælles forældre-komponent til komponent A og komponent B sender dataen ned i sine props gennem 
flere mellemled. Dette pattern kaldes *lifting-state-up*. [propsmellemledbillede]

Når man har en stor applikation med mange komponenter, som deler mange props, kan det blive uoverskueligt at vedligeholde med at løfte tilstanden, da det overholder ikke DRY princippet, eftersom den manuelle proces med at sende dataen igennem komponenten via props skal gentages for hvert enkelt mellemled mellem A og B. Dette anti-pattern kaldes *prop-drilling*.

### Redux
En måde at omgå denne "prop-drilling”  er ved at benytte Reacts indbyggede Context API. Den tillader komponenter at dele props indenfor en kontekst uden at mappe props mellem komponenter. [contextbillede]

En anden mere avanceret måde, er at gøre som Facebook og bruge software design mønstret Flux. Flux applikationer har tre hovedbestanddele: dispatcher, stores og views. Ideen med Flux er, at den delte state ligger i en single source of truth dvs. i stores. State i stores kan kun opdateres ved at trigge en action. Actions fortæller sine stateændringer (payload) til dispatcher. Stores lytter på ændringer fra dispatcher, og 
opdaterer deres egen state i overeensstemmelse hermed. 

Redux har også mulighed for middleware, som kan manipulere actions på vej ind og 
ud af reduceren. Dette giver mulighed for f. eks. asynkrone actions til API kald med 
redux-thunk middlewaren. Redux API’en giver også mulighed for at kombinere 
reducers med en higher order reducer funktion kaldet combineReducers. Det er altså 
en funktion, der tager flere reducers som parameter, og returnerer en ny kombineret 
reducer. Typisk har man en reducer slice for hver feature / domæne i projektet, som 
kombineres til en enkelt root reducer med combineReducers. Root reduceren bruges 
af Redux til at lave store objektet.  [reduxbillede]

For at forbinde sine React komponenter til sin Redux store anbefales det at bruge 
Redux API’ens connect funktion. Connect tager to funktioner som input og returnerer 
en funktion, som er en higher order component, der tager en React komponent som 
input og returnerer en ”forbedret” udgave af komponenten med adgang til store og 
action creators via props.  [providerbillede]

### Funktionel programmering
Disse software design mønstre, som optræder i React, kan virke eksotiske fra et objekt orienteret 
programmerings perspektiv, men de opstår som en naturlig konsekvens af, at React 
fremhæver det funktionelle programmerings paradigme frem for objekt orienteret 
programmering. Funktionel programmering er ikke nogen moderne opfindelse, da det 
har sine rødder i det matematiske felt lambda calculus som blev opfundet i 1936. Det 
består af nogle mønstre som f.eks. at skrive pure functions og sammensættte dem i 
higher order funktions samt at undgå mutation af værdier (immutability). Når man 
forstår de funktionelle koncepter, ser man dem gentage sig overalt i React. 

### React-DOM
Alt React kode som har med browseren at gøre, er splittet op i sit eget ReactDOM 
kodebibliotek. Man kan også udvikle med React mod en anden målplatform end 
browseren, ved at erstatte ReactDOM med et kodebibliotek til f.eks. cross-platform 
mobilapps (React Native) og konfiguration. Inde i maskineriet fungerer ReactDOM 
ved, at der fra webapplikationens index side kører en JavaScript fil i browseren, som 
holder browserens Document Object Model (DOM) synkroniseret med applikationens 
komposition af React komponenter og state. Alt logikken til at generere HTML 
dynamisk er således flyttet over i klienten/browseren. Denne client-side-rendering gør 
det muligt at have en interaktiv hjemmeside uden brug af en webserver. 

Selvom man har en SPA uden en webserver, kan man stadig have pseudorouting 
med JavaScripts History API eller React udgaven, React Router. Men det er altid 
index siden, der indlæser hele webapplikationen, som præsenterer indholdet ud fra
URL routen. Det medfører en bedre brugeroplevelse, da klienten aldrig indlæser en
ny side efter index siden, og dermed slipper for nogensinde at genindlæse siden. [routebillede]

React opdaterer kun de DOM elementer i browserens hukommelse, som det er
nødvendigt for at matche det tilsvarende React elements state. Denne optimisering
fremkommer af Reacts VDOM. Det er en virtuel kopi af DOM’en, som eksisterer med
den nyeste opdaterede state i hukommelsen. Før React opdaterer DOM, hvilket er en
meget dyr operation, sammenligner meget hurtige algoritmer VDOM med DOM og
finder de steder, hvor der er forskel i browserens DOM state fra Reacts interne VDOM
state, så kun de absolut nødvendige DOM elementer behøver at blive opdateret.  [reactdombllede]

React understøtter også server-side-rendering, hvor serveren foretager den første
indlæsning af webapplikationen og sender et snapshot af det fuldt formede HTML
dokument til klienten. På denne måde understøtter man bedre søgemaskine
crawlerne og opnår en bedre rank i søgemaskinen, og man mindsker markant tiden
før first meaningful paint (når man kan se sidens primære indhold). Med server-side-
rendering er man dog stadig nødt til at vente på, at browseren kører React scriptet,
før siden bliver interaktiv.  

### Hooks
https://itnext.io/under-the-hood-of-react-hooks-805dc68581c3

## Node (flyt)

Node er et open source runtime environment for JavaScript, som kan læse og
eksekvere JavaScript filer. Udover at være et runtime environment, indeholder Node
også moduler som gør det muligt at afvikle JavaScript på server-side, og derved at
implementere en webserver bygget på Node som f.eks. Express.

Selvom det ikke kræver Node eller en webserver at køre en React app, er Node en
del af alle React projekter. Det skyldes at Node også er den mest populære platform
for værktøjer til at gøre livet lettere når man arbejder med f.eks. React.

### CRA (Create-React-App)

tilføj: https://youtu.be/WQue1AN93YU?t=382
NPM var mest udbredt til backend, men i 2016 recently også frontend

Node installeres sammen med Node Package Manager (NPM) som samarbejder med
et register af JavaScript-pakker. Ved brug af dets Command Line Interface (CLI) kan
man nemt installere JavaScript-pakker fra NPM Registry til sit projekt og styre dependencies med
semantisk versionsstyring. Når man opretter et nyt React projekt, er første trin at bruge NPM 
(med dens script-runner, NPX) til at køre et scriptet CRA[^cra], som er udviklet af Facebook.

 `npx install create-react-app appnavn` 

Dette installerer en færdigkonfigureret starterpakke til React udvikling. Den 
indeholder bl.a. compilere, som udvider JavaScripts syntaks med JSX, og tillader at moderne sprogfunktioner/syntaks. Det giver også en samling af scripts (react-scripts[^rs]) til bl.a. at 
starte en lokal live udviklingswebserver baseret på Node, med hot-reloading af CSS-
filer og JavaScript-moduler, eller til at builde en produktionsklar statisk hjemmeside. 

### Indbyggede variabler
__dirname etc.

### Indbyggede moduler
path etc.

### module.exports etc 

[^cra]: https://www.npmjs.com/package/create-react-app
[^rs]: https://www.npmjs.com/package/react-scripts

## Node flyttes før webpack

## Webpack

### Tree shaking 
https://insights.untapt.com/webpack-import-require-and-you-3fd7f5ea93c0

CRA bruger en automatisk opsat Webpack konfiguration til at transpilere applikationens kildekode, hvilket tillader brug af `require` statements. Med `require` kan fra et JavaScript modul importere andre JavaScript moduler. Webpack er det, man kalder en *module bundler*. Det vil sige, at Webpacks primære formål er på buildtime at samle koden til én samlet JavaScript *bundle*, som indeholder alle applikationens moduler og deres indbyrdes afhængigheder. I konfigurationsfilen for Webpack definerer man et *entry point*, som Webpack skal starte i. Ud fra entry point kompilerer Webpack programmet og bygger undervejs en *dependency graph*, som repræsenterer alle webapplikationens moduler og afhængigheder. 

Med udgangspunkt i denne dependency graph, bundler webpack modulerne og afhængighederne sammen i én samlet JavaScript bundle, som er klar til at blive downloadet og præsenteret af browseren. Dette giver i sig selv en gevinst, for brugeren kan få hele webapplikationen i ét request. Det kan gøre indlæsningen af alle modulerne betydeligt hurtigere på en HTTP/1.1 forbindelse med høj latency, da HTTP/1.1 håndterer hvert request synkront og dermed blokerer renderingen indtil hver static asset er downloaded og eksekveret.


```{r echo=FALSE, fig.cap="Synkron asset download og eksekvering", fig.height=4, fig.width=4}
library(png)
library(grid)
img <- readPNG("sync-assets-http1.png")
grid.raster(img)
```


HTTP/2 protokollen tillader asynkron download af static assets, så her gør antallet af requests ikke den store forskel. Udover bundling af JavaScript moduler, kan man med Webpack også håndtere bl.a. importering af stylesheets, billedfiler og JSON, anvendelse af nonstandard syntaks, og meget mere[^webpack].

### Konfiguraton af Webpack
Webpack tillader at konfigurere...

For at komme i gang med at bruge webpack, behøver man ikke andet end Node. Man kan lave en ny tom mappe og installere Webpack:

```
npm init -y
npm i -D webpack
```

Som standard er Webpack konfigureret til at søge efter et entry point i `./src/index.js`. Hvis man prøver at køre webpack på sit tomme projekt, vil man få en fejlmeddelse, når man kører webpack med `npx webpack`. Hvis man vil ændre sit entry point, skal man oprette konfiguratonsfilen `webpack.config.js` i projektets rodmappe. En minimal konfigurationsfil, der ændrer entry point til en `main.js` fil i rodmappen, ser sådan ud:

```{js, fig.cap="Test"}
const config = {
  entry: './main.js',
};

module.exports = config;
```

Hvis overstående konfigurationsfil er til stede i rodmappen, vil Webpack automatisk samle den op, når man kører kommandoen `npx webpack` fra projektets rodmappe som arbejdsmappe. Hvis der findes en `main.js`, vil Webpack køre og resultere i en bundle i `./dist/bundle.js`.

For at ændre output filnavnet til fx. `output.js`, tilføjer man en `output` property til `config` objektet, med en `filename` property. For at placere output placeringen til fx. `./build/`, tilføjer man yderligere en `path` property til `output` objektet. 
```{js}
const config = {
  entry: './src/index.js',
  output: {
    path: __dirname + "/build/",
    filename: 'output.js'
  }
};

module.exports = config;
```


Og for at ændre 


### Loaders

Webpack giver mulighed for, at man kan indlæse trejdeparts *loaders* til at håndtere andre filtyper end JavaScript. Man konfigurerer webpack til at håndtere forskellige filtyper med forskellige loaders. Hver loader er en preprocessor, som Webpack anvender, når den støder på en angiven filtype. Loaders kan bl.a. sørge for, at CSS filer bliver bundled sammen og indlejret som et tag i HTML dokumentet, eller eller at mindre billedfiler bliver indlejret som en base64 data URL[^b64]. Endvidere vil webpack i *production mode* også optimere de genererede static assets ved at komprimere dem.

[^webpack]: https://github.com/webpack-contrib/awesome-webpack#loaders


```{r echo=FALSE, fig.cap="Webpack dependency graph transpilering til bundle", fig.height=4, fig.width=4}
library(png)
library(grid)
img <- readPNG("modules-dependencies-webpack.png")
grid.raster(img)
```


og oversætte moderne syntaks til bagudkompatibel

https://www.youtube.com/watch?v=WQue1AN93YU

[^b64]: Binær-til-tekst kodningsformat til at indlejre fx. billedfiler direkte i dokumentet i stedet for at importere. 

## Babel

`const element = <div className=”hello”>Hello, UCL!</div>` 

Overstående HTML-lignende syntaks er den syntaksudvidelse, som kaldes JSX. Det 
transpileres (af Webpack) med en loader (Babel) til standard JavaScript. Webpack er en modul bundler, som samler projektets 
ES 6 moduler (ved import/export statements) til én samlet kildekode, og med Babel 
oversætter speciel syntaks som f.eks. JSX til standard JavaScript. Overstående kode 
bliver oversat af Babel til noget lignende: 

```
const element = React.createElement( 
  “div”, 
  { className: “hello” }, 
  “Hello, Unik!” 
); // => Hello, Unik!
 ```

Det er også muligt at indlejre JavaScript i et JSX udtryk: 
```
const element = <div className=”hello”> Hello, { getSchool() }!</div> // => Hello, UCL! 
```
 

Babel understøtter også moderne syntaks som optional chaining `?` operatoren, som 
tillader at afbryde afviklingen af et udtryk uden fejl, hvis man prøvet at tilgå en 
property på et objekt med værdien null eller undefined, eller nullish coalescing `??` 
operatoren, som i tilfælde af ’null’ eller ’undefined’ falder tilbage på en anden værdi: 

```
let x = foo?.bar.baz(); // => 'undefined’ hvis ’foo’ er ’null’ eller ’undefined’ 

let y = foo ?? ”default”; // => “default” hvis foo er  null eller undefined 
```

En meget anvendt syntaks inden for React er arrow functions og logical && operator: 
const app = () => loggedIn && <Content /> 

 ```
Hvilket oversættes til følgende mindre kompakte syntaks i almindelig Javascript: 
function app() { 
  if (loggedIn) { 
    return React.createElement(Content, null); 
  } else { 
   return false; 
} 
```
 

Det er endda muligt at hente plugins til Babel for at understøtte ny eksperimentel 
syntaks, som måske kunne være på vej i en fremtidig ES standard. En syntaks som 
sandsynligvis vil komme i fremtiden, men lige nu er i et meget tidligt stadie, er de 
såkaldte algebraic effects, som kort sagt vil introducere komponerbare effect 
handlers til at behandle metodekald anderledes indenfor et scope med en try-catch 
agtig syntaks. Denne syntaks kan man allerede afprøve nu med et Babel plugin5. 

Babel kan også konfigureres til at understøtte TypeScript. Når man opretter et nyt 
projekt med create-react-app, kan man vælge at understøtte TypeScript med en 
template parameter: 

```
npx create-react-app --template typescript
```

Dette template indeholder en færdigkonfigureret Babel preset (babel-preset-react-app), som tillader at bruge ny syntaks som f.eks. type annotation (typestærkhed) og
at anvende TypeScripts compiler, som tillader statiske type checks af almindelig
JavaScript samt den udvidede TypeScript syntaks.

## TypeScript

TypeScript er en udvidelelse af JavaScript, som introducerer ny syntaks vi kender fra 
typestærke sprog ligesom C#, som f.eks. interfaces, enums og type annotation. Det 
introducerer også ny syntaks pga. dets anderledes typesystem, f. eks. muligheden for 
mapped types, der kan transformere en type fra en definition til en anden. 

Fordelene ved TypeScript er mange, men vigtigst er naturligvis den typesikkerhed, 
som man kan opnå med TypeScript på compile-time. Typesikkerhed er uvurderligt når 
man skal refaktorere gammel kode, da det giver mulighed for at ændre koden med en 
vis grad af tillid til, at der hvert fald ikke er introduceret nye fejl pga. inkompatible 
typer. Endnu bedre er automatiske tests, men UI kode er notorisk svær at dække med 
automatiserede tests.  

En anden fordel TypeScript har er, at det typestærkheden forbedrer dokumentation 
for koden. Hvis man importerer JavaScript moduler som har en korrekt type definition, 
kan man med sin IDE f.eks. udforske modulets eksporterede objekter, metoder, 
interfaces, etc. uden at man behøver nærlæse eller afvikle kildekoden. Med 
DefinitelyTyped registret, er det muligt at finde korrekte type definitioner til de fleste 
JavaScript kodebiblioteker, som endnu ikke har en officiel type definition (.d.ts fil). 

En af fordelene ved TypeScript er også, at det ligesom Babel er en transpiler, der 
oversætter syntaks, og man ser ofte nye syntaks funktioner i de nyeste versioner af 
TypeScript, før de kommer til ECMAScript. 

TypeScripts type system kaldes duck typing eller structural typing, hvilket 
differentierer sig fra f.eks. C#’s nominal typing ved at være mindre streng, når den 
skal bestemme hvorvidt et objekt overholder en type definition. Det bestemmes 
nemlig ved, om et objekt har properties, som er tilsvarende alle de properties et 
interface indeholder. Det er altså ligemeget, om den har yderligere properties, en 
anden type annotation eller måske slet ingen type annotation. Det er kun de 
properties, som udgør måltypens interface, der bliver taget i betragtning. 

```
interface IItem 
{ 
  id: number; 
} 
function doSomething(item: IItem) { } 
doSomething({ id: 1, name: “Rune” }); // OK! 
```

Et TypeScript interface som overstående genererer ikke noget kode når det 
oversættes til JavaScript, men TypeScript compileren bruger det interface til at 
verificere typekorrektheden i compile-time.TypeScript laver ikke nogle runtime type 
checks, da al TypeScript syntaksen kompileres til standard JavaScript inden kørsel. 

TypeScript compileren kan tit aflede datatypen for en variabel ud fra konteksten den 
bliver brugt. Det kaldes Type Inference, og det medfører, at man tit får mange af 
gevinsterne af statiske type checks før man overhovedet er begyndt at annotere sine 
data typer (hvilket faktisk er valgfrit at gøre). Hvis for eksempel en funktion 
’assertIsString(val)’ kaster en exception, når parameteren ’val’ har en anden type end 
’string’, kan TypeScript benytte sig af det til at give fejlbeskeder og code completion. 

```
function yell(str) { 
  assertIsString(str); // Nu ved TypeScript at ‘str’ har 
                       // typen ‘string’ 
  return str.toUppercase(); 
  // error: Property 'toUppercase' does not exist on 
  // type 'string'. Did you mean 'toUpperCase'? 
} 
```
TypeScript er endda i stand til at udlede data typer ud fra kommentarer ovenover 
koden, hvis kommentarerne er skrevet efter JSDoc specifikationen. 

## Pipelines

## Vue

# Micro Frontends

## Web Components
https://medium.com/rangle-io/everything-you-need-to-know-about-web-components-part-1-ced95964fbe6
https://medium.com/@amitleshed/building-web-components-with-native-custom-elements-8312d6e45fb3
https://codeburst.io/6-reasons-you-should-use-native-web-components-b45e18e069c2
https://books.google.dk/books?id=CDzlCwAAQBAJ&pg=PA82&lpg=PA82&dq=%22custom+element+api%22+browser+support&source=bl&ots=rZxaPcxbP4&sig=ACfU3U0VjQVbByK_3xd13N1mAXWqPKYj0w&hl=da&sa=X&ved=2ahUKEwjjgpf12rrpAhXE-6QKHcWKCqQQ6AEwBHoECAoQAQ#v=onepage&q=%22custom%20element%20api%22%20browser%20support&f=false
https://developer.mozilla.org/en-US/docs/Web/API/Window/customElements

Inspireret af komponenter i frameworks som React, giver de nye *web components* mulighed for at indkapsle template, style og logik i genbrugelige komponenter, som man kan importere og anvende direkte som et custom HTML tag i sin HTML. 

Man kan betragte indbyggede DOM elementer, fx. `input` og `form`, som genbrugelige komponenter, der indkapsler et template (HTML), en style (CSS) og en intern logik (JavaScript). På samme måde kan man med web components lave genbrugelige komponenter af ren HTML, CSS og JavaScript.


```{r echo=FALSE, fig.cap="Et typisk DOM element", fig.height=4, fig.width=4 }
library(png)
library(grid)
img <- readPNG("typical-dom-element.png")
grid.raster(img)
```

Den store fordel ved web components er, at de er integreret i webplatformen. Man har altså ikke behov for at indlæse et JavaScript framework som React, for at ens komponenter virker. Da web komponents altså er *framework agnostiske*, kan man også nemt integrere dem i andre frameworks, hvorimod man ikke umiddelbart kan integrere fx en React komponent i fx en Vue webapplikation. Dertil kan web components være fuldstændigt indkapslede, så man ikke skal bekymre sig om style creep (**link**). 

I stedet for at være afhængig af et specifikt JavaScript framework, anvender web components i stedet samling af nye specifikationer, som understøttes af alle moderne browsere, herunder især *Custom Elements* og *Shadow DOM*. 


### Custom Elements
Custom Element API tillader udvikleren at skabe nye *custom elements* (brugerdefinerede), som kan bruges ligesom andre HTML elementer. Man tilgår API'en med den nye `customElements` property på det globale `window` objekt. `customElements` er et objekt af typen `CustomElementRegistry`, som tillader at registrere et hvert objekt, som nedarver fra HTMLElement, med et HTML tagnavn, hvormed man knytter dem sammen, så browseren forstår sammenhængen. Når objektet er registreret, kan den bruges som markup direkte i HTML dokumentet. Selvom det i forvejen er tilladt at navngive sine egne HTML tags uden videre, har man altså brug for Custom Element API for at skabe sammenkoblingen mellem tagnavn og det brugerdefinerede DOM element.

 på *autonomous custom elements* (selvstændige) og *customized built-in elements* (tilpassede). De selvstændige custom elementer er helt uafhængige af standard HTML elementer. Man skaber dem ganske enkelt ved at lave et nedarvet objekt fra den generiske `HTMLElement` type. De er pt mere velunderstøttede[^caniuse_customelements] end de tilpassede. De tilpassede custom elmenter udvider i stedet funktionaliteten af standard elementerne, så man fx kan lave et brugerdefineret element, der udvider funktionaliteten af `video` tagget fra HTML5, ved at lave et nedarvet objekt fra HTMLVideoElement typen.


[^caniuse_customelements]: https://caniuse.com/#feat=custom-elementsv1


Man knytter sit selvstændige eller tilpassede custom element til et HTML tagnavn med `define` metoden på førnævnte `customElements` objekt. Hvis man laver et objekt, der (ligesom alle de standard HTML elementer) nedarver fra klassen `HTMLElement`, kan man give det objekt med som argument til `customElements.define` for at registrere sammenkoblingen.

```{js, fig.cap="testsetest"}
class MyCustomElement extends HTMLElement {}

window.customElements.define("my-custom-element", MyCustomElement);
```


Dette vil tillade at bruge `custom-element` tagget i sin HTML markup ligesom de standard HTML elementer. Indefra klassen har man så adgang til alle de properties, som udgør elementet. Man kan sætte `this.innerHtml` for at give den et template. Dette vil man typisk gøre i klassens constructor. 

```{js, fig.cap="testsetest"}
class MyCustomElement extends HTMLElement {}

window.customElements.define("my-custom-element", MyCustomElement);
```

For at give `CustomElement` noget mere funktionalitet, er det nødvendigt at kende til dens *component lifecycle*. Component lifecycle er en række metoder på det brugerdefinerede element, som kaldes på forskellige tidspunkter, fx. når elementet tilføjes til DOM eller skal opdateres.

Den første af disse component lifecycle metoder er `connectedCallback`, som bliver kaldt, når komponenten føjes til DOM.

https://developers.google.com/web/fundamentals/web-components/customelements#reactions

[^bfarrell]
[^bfarell]: @bfarrell


### Shadow DOM

## Polyfills
https://www.webcomponents.org/polyfills

## Module Federaton
https://github.com/webpack/webpack/issues/10352 
Module Federation er en ny (**dato**) funktion i Webpack (**link**), som spiller en vigtig rolle i microfrontend arkitekturen. Det er indtil videre kun i beta version. Det tillader at bundle hver eneste individuelle microfrontend med alle sine afhængigheder. Dermed kan man have en individuel proces/pipeline for at bygge og udgive hver enkelt microfrontend.

Module Federation giver mulighed for, at man angiver *shared dependencies*. Hvis man f.eks. har angivet `react` som afhængighed for to forskellige microfrontends, og indlæser begge microfrontends, kan 

## Single-SPA

# Litteratur